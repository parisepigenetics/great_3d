#!/usr/bin/env python3

"""Program to compute and visualise a 3D-transcriptome map.

Take a 3D gene positions file and a gene expression matrix, compute spatial correlation and visualise an interactive 3D graph of the spatial gene expression correlation
"""

import argparse
import pandas as pd
import plotly.graph_objects as go
from dash import Dash, dcc, html, dash_table
import dash_bootstrap_components as dbc

# Import package specific py_modules
import great_3d.genome_3D_integration as grtGI
import great_3d.base_calulations as greatCalc
import great_3d.plotly_graphs as greatPlot


# Command line arguments parsing
parser = argparse.ArgumentParser(description="3D transcription map, main program")
# Declare command line arguments
group = parser.add_mutually_exclusive_group(required=True)
group.add_argument("-s", "--gene-starts",
                   type=argparse.FileType("r"),
                   help="Path to the file containing genes, chromosome names and start site genomic coordinates",
                   dest="geneStarts",
                   metavar="genes_starts")
group.add_argument("-c", "--gene-3Dcoords",
                   type=argparse.FileType("r"),
                   help="Path to the file containing the 3D coordinates of genes",
                   dest="genePos",
                   metavar="genes_positions")
parser.add_argument("-e", "--geneExpression-file",
                    type=argparse.FileType("r"),
                    required=True,
                    help="Path to the file containing the gene expression",
                    dest="geneExpr",
                    metavar="gene_expression_table")
parser.add_argument("-g", "--genome-coordinates",
                    type=argparse.FileType("r"),
                    required=True,
                    help="Path to the file containing the genome coordinates in 3D",
                    dest="genome",
                    metavar="genome_coords")
parser.add_argument("-u", "--user-genes",
                    type=argparse.FileType("r"),
                    help="Path to the file with the user genes of interest",
                    default=None,
                    dest="userGenes",
                    metavar="genes_interest")
parser.add_argument("-n", "--nb-genes",
                    help="Number of neighbouring genes. (DEFAULT = 10)",
                    type=int,
                    default=10,
                    dest="nGenes",
                    metavar="noGenes")
parser.add_argument("-m", "--correlation-method",
                    help="Define correlation method. (DEFAULT = 'pearson')",
                    type=str,
                    default="pearson",
                    dest="mCorr",
                    metavar="correlation_method")
parser.add_argument("-r", "--resolution",
                    help="The Hi-C file bins size (resolution). (DEFAULT = 5000)",
                    type=int,
                    default=5000,
                    dest="resolution",
                    metavar="hicResolution")
parser.add_argument("-t", "--title",
                    help="Title for the 3D plotly praph. (DEFAULT = '')",
                    type=str,
                    default="",
                    dest="title",
                    metavar="title")

# Generate the options-arguments object
args = parser.parse_args()
# Calculate if needed the gene 3D coordinates
if args.genePos:
    genePos = pd.read_table(args.genePos)
elif args.geneStarts:
    genePos = grtGI.compute_gene_coordinates(args.geneStarts, args.genome, args.resolution)
else:
    raise IOError("One of --gene-3Dcoords or --gene-starts arguments must be declared.")

GRAPH_WIDTH = 1280  # In pixels
GRAPH_HEIGHT = 1280

def visualise_3D(traces):
    """Render figure layout for Plotly.
    - Args:
    - `traces`: The list of traces.
    - Return:
    - The Plotly figure.
    """
    # Set layout elements, size, margins, legend(s)
    layout = go.Layout(plot_bgcolor="#FFF",
                       autosize=False,
                       width=GRAPH_WIDTH,
                       height=GRAPH_HEIGHT,
                       margin=dict(l=1, r=1, b=1, t=1),
                       legend=dict(yanchor="top", y=0.99, xanchor="left", x=0.1),
                       modebar={"orientation": "h", "bgcolor": "salmon", "color": "white", "activecolor": "#9ED3CD"},
                       hoverlabel=dict(bgcolor='rgba(255,255,255,0.7)', font=dict(color='black')),
                       modebar_add=['drawline',
                                    'drawopenpath',
                                    'drawclosedpath',
                                    'drawcircle',
                                    'drawrect',
                                    'eraseshape'
                                    ]
                       )
    # Construct the figure
    fig = go.Figure(data=traces, layout=layout)
    # Render axes invisible - cleaner graph.
    fig.update_scenes(xaxis_visible=False,
                      yaxis_visible=False,
                      zaxis_visible=False
                      )
    return fig


# Calculations:
# Calculate the distance matrix
distanceMatrix = greatCalc.calculate_distance(genePos)
# Populate the dictionary of sorted distances.
sortedDict = greatCalc.sorting_distances(distanceMatrix)
# Compute a dictionnary of the sum of correlations between each gene and its neighbours.
sum_Corr = greatCalc.sum_correlation(sortedDict, args.geneExpr, args.nGenes, args.mCorr)

# Visualisations:
# Compute all visualisation tracks (traces)
traceGenome = greatPlot.visualise_genome_3D(args.genome)
traceGenes = greatPlot.visualise_genes(genePos)
# genePos, sum_Corr, args.userGenes)
# 3D visualization with Plotly
fig = visualise_3D([traceGenome, traceGenes])


# FIXME just to practice tables visualisation remove that later perhaps
args.geneExpr.seek(0)
with args.geneExpr as fh:
    df = pd.read_table(fh)
df.reset_index(inplace=True)
df.rename(columns={"index":"Gene Name"}, inplace=True)


# Dash application
# TODO Enrich the Dash application with, controls (radio buttons, sliders, etc.), input files and proress bars!!!
app = Dash("GREAT3D", external_stylesheets=[dbc.themes.BOOTSTRAP])
app.layout = html.Div([
        html.H3(html.B("GREAT 3D Transcriptome Map")),
        html.H2(args.title, style={'textAlign': 'center'}),
        html.Hr(),
        dbc.Row([
            dbc.Col(html.Div([
                dcc.Graph(id='dash_GREAT', figure=fig)
                ]),
                    width=9),
            dbc.Col(html.Div([
                html.H3("Options"),
                html.Hr(),
                html.Label('Tracks:', style={'paddingTop': '2rem', 'display': 'inline-block'}),
                dcc.Checklist(
                    id='input_track',
                    options=[
                        {'label': 'Genes', 'value': 'genes'},
                        {'label': 'Correlation', 'value': 'corr'},
                        {'label': '|Correlation|', 'value': 'absCorr'}
                        ],
                    value=['genes', 'corr', 'absCorr'])
                ]), 
                    width=3)
            ]),
        html.Hr(),
        html.H3("Expression Data"),
        dash_table.DataTable(
            data=df.to_dict('records'),
            page_size=20,
            id='expression_data',
            columns=[{"name": i, "id": i} for i in df.columns],
            style_table={'overflow': 'scroll', 'height': 800},
            style_header={'font_size': '14px', 'backgroundColor': '#305D91', 'padding': '15px', 'color': '#FFFFFF'},
            style_cell={'textAlign': 'center', 'minWidth': 60, 'maxWidth': 400, 'width': 90, 'font_size': '12px', 'whiteSpace': 'normal', 'height': 'auto', 'padding': '10px'},
            filter_action="native",      # allow filtering of data by user ('native') or not ('none')
            sort_action="native",        # enables data to be sorted per-column by user or not ('none')
            sort_mode="single",          # sort across 'multi' or 'single' columns
            column_selectable="single",  # allow users to select 'multi' or 'single' columns
            row_selectable="multi",      # allow users to select 'multi' or 'single' rows
            selected_columns=[],         # ids of columns that user selects
            selected_rows=[],            # indices of rows that user selects
            fill_width=False,
            page_action="native")
])

# TODO here will go the callbacks

if __name__ == '__main__':
    app.run()  # (debug=True)
